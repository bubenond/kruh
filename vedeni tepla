#include <iostream>
#include <vector>
#include <cmath>

// ----------------------------------------------------------
// Parametry fyzikÃ¡lnÃ­ho modelu
// ----------------------------------------------------------
const double Lx = 0.05;   // [m] dÃ©lka tÄ›lesa (napÅ™. baterie 5 cm)
const double Ly = 0.03;   // [m]
const double Lz = 0.005;  // [m]

const int Nx = 30, Ny = 20, Nz = 10;  // poÄet uzlÅ¯
const double dx = Lx / (Nx - 1);
const double dy = Ly / (Ny - 1);
const double dz = Lz / (Nz - 1);

const double rho = 2700.0;   // hustota [kg/m3] (napÅ™. hlinÃ­k)
const double cp  = 900.0;    // mÄ›rnÃ¡ tepelnÃ¡ kapacita [J/kgK]
const double lambda = 200.0; // tepelnÃ¡ vodivost [W/mK]

const double dt = 0.001;     // ÄasovÃ½ krok [s]
const double t_end = 2.0;    // koneÄnÃ½ Äas simulace [s]

const double T_ambient = 293.15;  // [K] poÄÃ¡teÄnÃ­ i okrajovÃ¡ teplota

// ----------------------------------------------------------
// PomocnÃ© funkce pro indexaci 3D pole v 1D vektoru
// ----------------------------------------------------------
inline int idx(int i, int j, int k) {
    return i + Nx * (j + Ny * k);
}

// ----------------------------------------------------------
// Funkce zdroje tepla (Jouleovo teplo) Q(x,y,z,t)
// ----------------------------------------------------------
double heatSource(double x, double y, double z, double t) {
    // NapÅ™. zdroj uprostÅ™ed baterie (GaussÅ¯v rozloÅ¾enÃ­)
    double xc = Lx / 2, yc = Ly / 2, zc = Lz / 2;
    double sigma = 0.01;
    double Q0 = 5e5; // [W/m3]
    return Q0 * exp(-((x-xc)*(x-xc)+(y-yc)*(y-yc)+(z-zc)*(z-zc))/(2*sigma*sigma));
}

// ----------------------------------------------------------
// HlavnÃ­ program
// ----------------------------------------------------------
int main() {
    const int N = Nx * Ny * Nz;
    std::vector<double> T(N, T_ambient);
    std::vector<double> Tnew(N, T_ambient);

    double alpha = lambda / (rho * cp); // teplotnÃ­ difuzivita

    int nsteps = static_cast<int>(t_end / dt);
    for (int step = 0; step < nsteps; ++step) {

        for (int k = 1; k < Nz - 1; ++k)
            for (int j = 1; j < Ny - 1; ++j)
                for (int i = 1; i < Nx - 1; ++i) {

                    double x = i * dx;
                    double y = j * dy;
                    double z = k * dz;

                    int p = idx(i, j, k);

                    // DruhÃ© derivace podle x, y, z
                    double d2Tdx2 = (T[idx(i+1,j,k)] - 2*T[p] + T[idx(i-1,j,k)]) / (dx*dx);
                    double d2Tdy2 = (T[idx(i,j+1,k)] - 2*T[p] + T[idx(i,j-1,k)]) / (dy*dy);
                    double d2Tdz2 = (T[idx(i,j,k+1)] - 2*T[p] + T[idx(i,j,k-1)]) / (dz*dz);

                    double Q = heatSource(x, y, z, step * dt);

                    // ExplicitnÃ­ schÃ©ma
                    Tnew[p] = T[p] + dt * (alpha * (d2Tdx2 + d2Tdy2 + d2Tdz2) + Q / (rho * cp));
                }

        // OkrajovÃ© podmÃ­nky â€“ konstantnÃ­ teplota
        for (int k = 0; k < Nz; ++k)
            for (int j = 0; j < Ny; ++j)
                for (int i = 0; i < Nx; ++i) {
                    if (i == 0 || i == Nx-1 || j == 0 || j == Ny-1 || k == 0 || k == Nz-1)
                        Tnew[idx(i,j,k)] = T_ambient;
                }

        // Aktualizace pole
        T.swap(Tnew);

        // VÃ½pis informacÃ­
        if (step % 100 == 0)
            std::cout << "t = " << step * dt << " s, T_center = "
                      << T[idx(Nx/2, Ny/2, Nz/2)] << " K" << std::endl;
    }

    std::cout << "Simulace hotova." << std::endl;
    return 0;